package uk.ac.ed.epcc.safe.accounting.policy;

import uk.ac.ed.epcc.safe.accounting.UsageRecord;
import uk.ac.ed.epcc.safe.accounting.db.AccountingUpdater;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordFactory.Use;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordParseTarget;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyContainer;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyMap;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyTag;
import uk.ac.ed.epcc.safe.accounting.reference.ReferencePropertyRegistry;
import uk.ac.ed.epcc.safe.accounting.reference.ReferenceTag;
import uk.ac.ed.epcc.webapp.AppContext;
import uk.ac.ed.epcc.webapp.Indexed;
import uk.ac.ed.epcc.webapp.model.data.reference.IndexedProducer;
import uk.ac.ed.epcc.webapp.model.data.reference.IndexedReference;

/** A policy to invoke a nested parse on a String property generated by the parent parse.
 * 
 * @author spb
 *
 */

public class NestedParsePolicy extends BaseUsageRecordPolicy {
	

	ReferenceTag parent_tag;
	AppContext conn;
	PropertyTag<String>  parse_prop;
	String nested_table;
	public NestedParsePolicy() {
			}

	@Override
	public PropertyFinder initFinder(AppContext ctx, PropertyFinder prev, String table) {
		
		String prop_name = ctx.getInitParameter("nested_parse.prop."+table);
		nested_table = ctx.getInitParameter("nested_parse.table."+table);
		if( prop_name != null){
			parse_prop = (PropertyTag<String>) prev.find(String.class, prop_name);
			this.conn=ctx;
			ReferencePropertyRegistry registry = ReferencePropertyRegistry.getInstance(ctx);
			
			parent_tag = (ReferenceTag) registry.find(table);
		}
		return prev;
	}

	@Override
	public void postCreate(PropertyContainer props, UsageRecord rec) throws Exception {
		
		if( parse_prop != null){
			String update = props.getProperty(parse_prop);
			if( update != null ){
				UsageRecordParseTarget<Use, String> parse_target = conn.makeObject(UsageRecordParseTarget.class, nested_table);
			    PropertyMap meta_data = new PropertyMap();      
			    meta_data.setAll(props);
			  
			    IndexedReference parent_ref = ((IndexedProducer)parse_target).makeReference((Indexed)rec);
			    meta_data.setProperty(parent_tag, parent_ref);
				AccountingUpdater<Use, String> updater = new AccountingUpdater<Use, String>(conn, meta_data, parse_target);
				updater.receiveAccountingData(update, true, false, false);
				
				
			}
		}
		
	}

}
