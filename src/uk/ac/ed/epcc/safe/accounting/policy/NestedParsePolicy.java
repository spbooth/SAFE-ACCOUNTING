package uk.ac.ed.epcc.safe.accounting.policy;

import uk.ac.ed.epcc.safe.accounting.UsageRecord;
import uk.ac.ed.epcc.safe.accounting.db.AccountingUpdater;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordFactory;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordFactory.Use;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordParseTarget;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyContainer;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyMap;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyTag;
import uk.ac.ed.epcc.safe.accounting.reference.ReferencePropertyRegistry;
import uk.ac.ed.epcc.safe.accounting.reference.ReferenceTag;
import uk.ac.ed.epcc.webapp.AppContext;
import uk.ac.ed.epcc.webapp.Indexed;

/** A policy to invoke a nested parse on a String property generated by the parent parse.
 * 
 * A String value is extracted from the parse 
 * (property name defined in <b>nested_parse.prop.<i>table-name</i></b>)
 * A nested parse is then applied to this string and stored in the table 
 * <b>nested_parse.table.<i>table-name</i></b>
 * To allow the nested table to back-reference to the parent table a reference to the parent record is added
 * to the set of externally defined properties passed to the parse (the target table must include the reference
 * registry and contain a reference field to the parent.
 * 
 * Optionally if the property <b>nested_parse.link.<i>table-name</i></b> is set to the name of an
 * integer property the value of that property is pre-pended to the parse string (separated by a space).
 * 
 * @author spb
 *
 */

public class NestedParsePolicy extends BaseUsageRecordPolicy {
	
	AppContext conn;
	String table_name, nested_table_name;
	String link_prop_name;
	PropertyTag<Integer> link_prop;
	PropertyTag<String> nested_prop;
	ReferenceTag parent_tag;
	UsageRecordFactory parent_fac;
	UsageRecordParseTarget<Use, String> parse_target;
	
	public NestedParsePolicy() {
	}

	
	@Override
	public PropertyFinder initFinder(AppContext conn, PropertyFinder prev, String table_name) {
		
		this.conn = conn;
		this.table_name = table_name;
		
		link_prop_name = conn.getInitParameter("nested_parse.link." + table_name);
		if( link_prop_name != null ){
			link_prop = (PropertyTag<Integer>) prev.find(Integer.class, link_prop_name);
		}
		
		String prop_name = conn.getInitParameter("nested_parse.prop." + table_name);
		if( prop_name != null ){
			nested_prop = (PropertyTag<String>) prev.find(String.class, prop_name);
			nested_table_name = conn.getInitParameter("nested_parse.table." + table_name);
			parse_target = conn.makeObject(UsageRecordParseTarget.class, nested_table_name);
		}
		
		ReferencePropertyRegistry registry = ReferencePropertyRegistry.getInstance(conn);
		parent_tag = (ReferenceTag) registry.find(table_name);
	
		
		return prev;
		
	}

	
	@Override
	public void postCreate(PropertyContainer props, UsageRecord rec) throws Exception {
		
		if( nested_prop != null && parse_target != null){
			
			String update = rec.getProperty(nested_prop);
			if( update != null ){
				
				if (link_prop_name != null) {
				    update = link_prop_name + "=" + rec.getProperty(link_prop).toString() + " " + update;
				}
				
				PropertyMap meta_data = new PropertyMap();      
			    meta_data.setAll(props);
			    if (parent_tag != null) {
			    	parent_tag.set(meta_data, (Indexed)rec);
			    }
				
				AccountingUpdater<Use, String> updater = new AccountingUpdater<Use, String>(conn, meta_data, parse_target);
				updater.receiveAccountingData(update, true, false, false);
				
			}
			
		}
		
	}


}
