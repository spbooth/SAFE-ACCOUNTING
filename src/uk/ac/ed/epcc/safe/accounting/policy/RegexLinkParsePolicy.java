package uk.ac.ed.epcc.safe.accounting.policy;

import java.util.LinkedHashSet;
import java.util.Set;

import uk.ac.ed.epcc.safe.accounting.db.RegexpTarget;
import uk.ac.ed.epcc.safe.accounting.db.RegexpTargetFactory;
import uk.ac.ed.epcc.safe.accounting.expr.PropExpressionMap;
import uk.ac.ed.epcc.safe.accounting.properties.InvalidPropertyException;
import uk.ac.ed.epcc.safe.accounting.properties.MultiFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyContainer;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyMap;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyTag;
import uk.ac.ed.epcc.safe.accounting.reference.ReferencePropertyRegistry;
import uk.ac.ed.epcc.safe.accounting.reference.ReferenceTag;
import uk.ac.ed.epcc.safe.accounting.update.AccountingParseException;
import uk.ac.ed.epcc.webapp.AppContext;
import uk.ac.ed.epcc.webapp.jdbc.table.ReferenceFieldType;
import uk.ac.ed.epcc.webapp.jdbc.table.TableSpecification;
import uk.ac.ed.epcc.webapp.logging.Logger;
import uk.ac.ed.epcc.webapp.model.data.reference.IndexedReference;

/** A policy to invoke a nested parse on a String property generated by the parent parse.
 * 
 * @author spb
 *
 */

public class RegexLinkParsePolicy extends BaseUsageRecordPolicy {
	private AppContext conn;
	private String table;
	private String target_table;
	private PropertyTag<String> link_prop;
	private ReferenceTag target_prop;
	private Set<RegexpTarget> targets; 
	private int links,records;
	
	public RegexLinkParsePolicy() {
	}
	
	@Override
	public PropertyFinder initFinder(AppContext conn, PropertyFinder prev, String table) {
		this.conn=conn;
		this.table=table;
		Logger log = getLogger(conn);
		MultiFinder finder = new MultiFinder();
		finder.addFinder(prev);
		finder.addFinder(ReferencePropertyRegistry.getInstance(conn));
		try {
				
			String link_name = conn.getInitParameter("regex_link_parse.link." + table);
			if (null == link_name) {
				throw new AccountingParseException("Error, regex_link_parse.link." + table + " not set.");
			}
			link_prop = (PropertyTag<String>) prev.find(String.class, link_name);
			if (null == link_prop) {
				log.error("Error, cannot find " + link_name + " property.");
				return prev;
			}
			
			
			
			
			target_table = conn.getInitParameter("regex_link_parse.table." + table);
			if (null == target_table) {
				log.error("Error, regex_link_parse.table." + table + " not set.");
				return prev;
			}	
			PropertyTag prop = finder.find(IndexedReference.class, target_table);
			if( prop != null && prop instanceof ReferenceTag){
				target_prop = (ReferenceTag) prop;
			}else{
				getLogger(conn).error("No target_prop found");
			}
			
		} catch (Exception e) {
			getLogger(conn).error("Error initialising RegexLinkParsePolicy",e);
		}
		
		return finder;
	}
	
	@Override
	public void parse(PropertyMap rec) throws AccountingParseException {
		records++;
		
		if( link_prop == null || target_prop == null){
			return;
		}

		String link_data = rec.getProperty(link_prop);
		if( link_data != null && ! link_data.isEmpty()){
			for( RegexpTarget tar : targets){

				if( tar.getRegexp().matcher(link_data).matches()) {
					try {
						target_prop.set(rec, tar);
					} catch (InvalidPropertyException e) {
						throw new AccountingParseException(e);
					}
					links++;
					break;
				}
			}
		}
	}

	@Override
	public void startParse(PropertyContainer staticProps) throws Exception {
		targets = new LinkedHashSet<RegexpTarget>();
		RegexpTargetFactory rt_fac = conn.makeObject(RegexpTargetFactory.class,target_table);
		rt_fac.all().toCollection(targets);
		links=0;
		records=0;
	}

	@Override
	public String endParse() {
		targets=null;
		return ""+links+" records out of "+records+" linked";
	}

	@Override
	public TableSpecification modifyDefaultTableSpecification(AppContext c, TableSpecification spec,
			PropExpressionMap map, String table_name) {
		TableSpecification ss = super.modifyDefaultTableSpecification(c, spec, map, table_name);
		String target_table = c.getInitParameter("regex_link_parse.table." + table_name);
		if( target_table != null ){
			ss.setField(target_table+"ID", new ReferenceFieldType(target_table));
		}
		return ss;
	}
	

}

