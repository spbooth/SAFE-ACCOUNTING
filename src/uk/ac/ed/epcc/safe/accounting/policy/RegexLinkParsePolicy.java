package uk.ac.ed.epcc.safe.accounting.policy;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import uk.ac.ed.epcc.safe.accounting.db.RegexpTarget;
import uk.ac.ed.epcc.safe.accounting.db.RegexpTargetFactory;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyMap;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyTag;
import uk.ac.ed.epcc.safe.accounting.update.AccountingParseException;
import uk.ac.ed.epcc.webapp.AppContext;

/** A policy to invoke a nested parse on a String property generated by the parent parse.
 * 
 * @author spb
 *
 */

public class RegexLinkParsePolicy extends BaseUsageRecordPolicy {
	
	PropertyTag<String> link_prop;
	PropertyTag<Integer> target_prop;
	Set<RegexpTarget> targets = new LinkedHashSet();
	
	public RegexLinkParsePolicy() {
	}
	
	@Override
	public PropertyFinder initFinder(AppContext conn, PropertyFinder prev, String table) {
		
		try {
				
			String link_name = conn.getInitParameter("regex_link_parse.link." + table);
			if (null == link_name) {
				throw new AccountingParseException("Error, regex_link_parse.link." + table + " not set.");
			}
			link_prop = (PropertyTag<String>) prev.find(String.class, link_name);
			if (null == link_prop) {
				throw new AccountingParseException("Error, cannot find " + link_name + " property.");
			}
			
			String target_name = conn.getInitParameter("regex_link_parse.target." + table);
			if (null == target_name) {
				throw new AccountingParseException("Error, regex_link_parse.target." + table + " not set.");
			}
			target_prop = (PropertyTag<Integer>) prev.find(Integer.class, target_name);
			if (null == target_prop) {
				throw new AccountingParseException("Error, cannot find " + target_name + " property.");
			}
			
			String target_table = conn.getInitParameter("regex_link_parse.table." + table);
			if (null == target_table) {
				throw new AccountingParseException("Error, regex_link_parse.table." + table + " not set.");
			}	
			
			RegexpTargetFactory rt_fac = conn.makeObject(RegexpTargetFactory.class,target_table);
			rt_fac.all().toCollection(targets);
		} catch (Exception e) {
			conn.error(e, "Error initialising RegexLinkParsePolicy");
		}
		
		return prev;
	}
	
	@Override
	public void parse(PropertyMap rec) throws AccountingParseException {
		
		String link_data = rec.getProperty(link_prop);
		for( RegexpTarget tar : targets){
		
			if( tar.getRegexp().matcher(link_data).matches()) {
				rec.setProperty(target_prop, tar.getID());
				break;
			}
		}
		
	}
	

}

