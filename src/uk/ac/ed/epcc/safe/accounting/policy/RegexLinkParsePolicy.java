package uk.ac.ed.epcc.safe.accounting.policy;

import uk.ac.ed.epcc.safe.accounting.db.UsageRecordParseTarget;
import uk.ac.ed.epcc.safe.accounting.db.UsageRecordFactory.Use;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyFinder;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyMap;
import uk.ac.ed.epcc.safe.accounting.properties.PropertyTag;
import uk.ac.ed.epcc.safe.accounting.update.AccountingParseException;
import uk.ac.ed.epcc.webapp.AppContext;
import uk.ac.ed.epcc.webapp.Indexed;
import uk.ac.ed.epcc.webapp.model.data.reference.IndexedProducer;
import uk.ac.ed.epcc.webapp.model.data.reference.IndexedReference;

/** A policy to invoke a nested parse on a String property generated by the parent parse.
 * 
 * @author spb
 *
 */

public class RegexLinkParsePolicy extends BaseUsageRecordPolicy {
	
	AppContext conn;
	String table_name, linked_table_name;
	PropertyTag<String> linked_prop;
	
	
	public RegexLinkParsePolicy() {
	}

	
	@Override
	public PropertyFinder initFinder(AppContext conn, PropertyFinder prev, String table) {
		
		this.conn = conn;
		this.table_name = table_name;
		
		String prop_name = conn.getInitParameter("regex_link_parse.prop." + table_name);
		if( prop_name != null ){
			linked_prop = (PropertyTag<String>) prev.find(String.class, prop_name);
			linked_table_name = conn.getInitParameter("regex_link_parse.table." + table_name);
		}
		
		return prev;
	}
	
	@Override
	public void parse(PropertyMap rec) throws AccountingParseException {
		
		String linked_name = rec.getProperty(linked_prop);
		
		UsageRecordParseTarget<Use, String> link_target = conn.makeObject(UsageRecordParseTarget.class, table_name);
		IndexedReference link_ref = ((IndexedProducer) link_target).makeReference((Indexed) rec);
	    
		// for each entry in <linked_table_name> table
		  // if regular expression defined by <linked_regex> matches linked_name
		    // set reference
		    // break
	}
	

}

